# PBS 168 of X â€” YAML: Introduction

As part of our re-building of XKPasswd we are making use of all sorts of developer tooling. The intention is that when we're done, we'll have explained all the pieces of that tooling within the series.

There are two ways in which YAML intersects with this series:

1. Many modern developer tools use YAML for their configuration files
2. Many modern Markdown-based static site generators use YAML for configuration and for metadata, including Jekyll, the Static Site Generator that powers GitHub Pages. This series is written in Markdown and published as a GitHub Pages using a custom Jekyll Theme.

YAML is designed for more than just config files and data representation, but those are the features we'll be confining ourselves to here.

TO EXPAND

## Matching Podcast Episode

TO DO

## Instalment Resources

* The instalment ZIP file â€” [pbs168.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs168.zip) TO GENERATE IF NEEDED

## Some Historical Context

Before we explore YAML, I think it helps to place it within a larger historical context. YAML didn't arrive into a vacuum, its design was informed by the pain-points exposed by its predecessors. After all, we've been trying to find ways of representing data in text files for decades!

In the earliest days of computing we used primitive data formats like **fixed-width field text files**:

```text
Timestamp           Severity Message
2023-12-25T23:30:03 INFO     Carrot & Cookie placed on mantle piece
2023-12-25T23:45:42 NOTICE   Vibration detected by roof sensor
2023-12-25T23:50:32 NOTICE   Motion detected by chimney sensor     
```

The way this worked is that there's some documentation on someone's desk that says the first field will be 19 characters long, then there will be a space, them the second field will be 8 characters long, then there will be a space, then the final field will fill the rest of the line.

These kinds of formats are very human-readable, but, they're also spectacularly brittle â€” one line of code somewhere that doesn't check a field length and everything breaks. Not to mention how difficult it is to change your mind about the structure of the data â€” extending or adding a fields requires a careful review of every single line of code that processes the file to make sure all the offsets are corrected.

In my entire professional life I have encountered just one production system using fixed-width fields, and we did need to alter the structure, and it was an absolute nightmare!

As well as being brittle these files are also very limited â€” they can only represent tabular data containing strings and numbers, they can't represent lists of dictionaries.

Because fixed-width fields were so difficult to work with they were soon followed by **Tab-Separated Values** (TSV), and shortly after that, Coma-Separated Values (CSV) files.

A TSV file (also called a *tab file*) looks superficially similar to a fixed-width field file, but instead of counting characters, the fields are separated by tab characters:

```tsv
Timestamp	Severity	Message
2023-12-25T23:30:03	INFO	Carrot & Cookie placed on mantle piece
2023-12-25T23:45:42	NOTICE	Vibration detected by roof sensor
2023-12-25T23:50:32	NOTICE	Motion detected by chimney sensor 
```

TSV files are less brittle because you don't need to count character offsets anymore, but you now have twi new problems:

1. Your data can't contain tabs
2. Humans can't see the difference between tabs and spaces easily, so debugging corrupted TSV files can be infuriating!

**Coma-Separated Values (CSV)** improve on TSV files a little more by making two changes:

1. Fields are separated with comas not tabs, this makes them easier for humans to debug
2. The specification includes support for quoting field data so it can include comas and even escaped quotation marks

This gives us what is now by far the most widely used generic text format for tabular data:

```csv
Timestamp,Severity,Message
2023-12-25T23:30:03,INFO,"Carrot & Cookie placed on mantle piece"
2023-12-25T23:45:42,NOTICE,"Vibration detected by roof sensor"
2023-12-25T23:50:32,NOTICE,"Motion detected by chimney sensor"
```

However, note that both TSVs and CSVs have sacrificed readability for robustness, because the field boundaries no longer line up, you need to count separators to know which column you're reading. And, like fixed-width fields, TSVs and CSVs are limited to tabular data.

The next text-based data format really take off was the **Extensible Markup Language**, or XML.

Because of it's enthusiastic adoption by major enterprise vendors like Sun Microsystems in Java, Oracle in their various enterprise platforms, and Microsoft in IIS, XML is still doing a lot of heavy lifting to this day!

XML is not built around the idea of lines with separated fields, instead, it uses nested tags. This means you can represent just about any data structure you like in XML. And, with some sensible indentation and some syntax highlighting it's actually quite human readable:

```xml
<message>
  <timestamp>2023-12-25T23:30:03</timestamp>
  <severity>INFO</severity>
  <message>Carrot &amp; Cookie placed on mantle piece</message>
</message>
  <timestamp>2023-12-25T23:45:42</timestamp>
  <severity>NOTICE</severity>
  <message>Vibration detected by roof sensor</message>
<message>
  <timestamp>2023-12-25T23:50:32</timestamp>
  <severity>NOTICE</severity>
  <message>Motion detected by chimney sensor</message>
</message>
```

So, while XML is powerful and pretty human-readable, it's also extremely verbose! The power and the human-readableness come at the price of wasted disk space and/or bandwidth.

The next contender to really make a splash was **JSON**, which we've already made heavy use of throughout this series.

Like XML, JSON can represent complex data types and is very human-readable. But it does so while being much less verbose, and hence, less inefficient:

```json
[
  {
    "timestamp": "2023-12-25T23:30:03",
    "severity": "INFO",
    "message": "Carrot & Cookie placed on mantle piece"
  },
  {
    "timestamp": "2023-12-25T23:45:42",
    "severity": "NOTICE",
    "message": "Vibration detected by roof sensor"
  },
  {
    "timestamp": "2023-12-25T23:50:32",
    "severity": "NOTICE",
    "message": "Motion detected by chimney sensor"
  }
]
```

Finally, we get to **YAML**, which takes things just that little bit further by being even more human-readable, and even more efficient than JSON:

```yaml
- timestamp: 2023-12-25T23:30:03
  severity: INFO
  message: Carrot & Cookie placed on mantle piece
- timestamp: 2023-12-25T23:45:42
  severity: NOTICE
  message: Vibration detected by roof sensor
- timestamp: 2023-12-25T23:50:32
  severity: NOTICE
  message: Motion detected by chimney sensor
```

## YAML's Philosophy

As I said in the introduction, YAML was designed to solve many problems, not just those we are interested in. Quoting from the [specification](https://yaml.org/spec/1.2.2/) (emphasis added):

> YAML (a recursive acronym for â€œYAML Ainâ€™t Markup Languageâ€) is a data serialization language designed to be **human-friendly** and work well with modern programming languages for common everyday tasks.
>
> â€¦
>
> There are hundreds of different languages for programming, but only a handful of languages for storing and transferring data. Even though its potential is virtually boundless, YAML was specifically created to work well for common use cases such as: **configuration files**, log files, interprocess messaging, **cross-language data sharing**, object persistence and debugging of complex data structures. **When data is easy to view and understand, programming becomes a simpler task**.

### Terminology

Firstly, to make YAML as flexible as possible, it was designed from the ground up to allow YAML data to be embedded within other file formats, and, to allow multiple distinct pieces of YAML data be stored within a single file or data stream. The YAML specification refers to each of these separate chunks of YAML data as *Documents*. So, to put it another way, YAML documents can be embedded within any file, and you can embed as many YAML documents as you like.

Secondly, because YAML was designed to be very generic, it provides single representations for data types that have many synonyms in other languages. This means that for each core concept, the YAML designers had to choose one official synonym for use in the YAML spec. 

This is how YAML spec represents data:

* **Documents** â€” one or more pieces of data
  * **Scalars** â€” single values like a string or a number
  * **Collections** â€” compound values that come in two flavours:
    * **Sequences** â€” lists of values, AKA arrays
    * **Mappings** â€” key-value pairs, AKA dictionaries, hash tables, lookup tables etc.

## YAML Versions

The most recent major version of the YAML specification is YAML 1.2 which was released in 2009, replacing YAML 1.1 which dated back to 2005. The most recent revision is  YAML 1.2.2 which was released in 2021, and that's the spec I've used as my reference for these notes.

When writing new YAML documents, always use the newest version of the spec, but it can sometimes be useful to know about aspects of the older spec when reading YAML snippets online. The most notable such example is the changes to Booleans which we'll describe shorty.

## Visualising our YAML (with the help of `yq`)

Before we dive into how YAML works, we're going to need a way of illustrating what data a piece of YAML code represents. What we need is a translation between the YAML snippets we don't yet understand, and some data format we're already intimately familiar with. Give our journey in this series, JSON seemed the most suitable option.

So, throughout our exploration of YAML I'll be using YAML â†’ JSON conversions to illustrate the various concepts. I performed these conversions using a very interesting new command line tool named `yq` which is heavily inspired by `jq`, but can read and output information from multiple data formats, including both JSON & YAML.

**I've already performed all the needed conversions and included the resulting JSON directly into the show notes**, so you don't need to install `yq`, but if you'd like to, you can learn all about it on their [GitHub page](https://github.com/mikefarah/yq). Also, if you use a Mac, you can install it via [Homebrew](https://brew.sh) (like we did `jq`) with the command:

```sh
brew install yq
```

If you're curious how I did the conversions without needing to save the YAML snippets into files first, I use the Mac terminal command `pbpaste` send the contents of my clipboard into `yq`. So, my process was to simply copy the YAML snipped from the notes, then run either of the following terminal commands:

```sh
# for long output
pbpaste | yq -o=j

# for compact output
pbpaste | yq -o=j -I=0
```

> _**Note:** There are actually two tools with the name `yq`, the other one is a simple Python-based wrapper around `jq` that converts YAML to JSON using Python's native libraries, and then passes that JSON to the `jq` command for processing and rendering. This is a rather crude tool, it has a lot of prerequisites, including Python,  but if you're a Python user anyway you may find it useful â€” you can get the details on their [their GitHub page](https://github.com/kislyuk/yq)._
{: .aside}

## Basic YAML Syntax

First off, let's cover some some fundamental concepts.

### Starting & Ending Documents

In YAML so-called *structures* are used to signal to signal the start and/or end of the YAML document to a YAML interpreter.

There are just two structures, and both have to appear by themselves on a single line:

| YAML Structure | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| `---`          | Start a new YAML document, if there is already one started, start a new one. |
| `...`          | End a YAML document without starting a new one.              |

This means that, according to the spec, you should start your embedded YAML with `---`, and end it with `...`.

As an interesting side-note â€” for reasons I don't quite understand, many Markdown-based static site generators choose not to follow the spec, and instead to require that the YAML-formatted metadata (the so-called *front matter*) be added at the very start of the file, and both start and end with `---` structures. Both [Jekyll](https://jekyllrb.com/docs/step-by-step/03-front-matter/) and [Obsidian](https://help.obsidian.md/Editing+and+formatting/Properties) use this approach.

### YAML Comments

Unlike JSON, YAML does support comments, but unlike most proper programming languages, it does not offer a menu of comment syntaxes to choose from â€” YAML supports only Bash-style `#` comments.

That is to say, lines starting with `#` are ignored, as is a `#` and everything appearing after it on non-empty lines.

```yaml
---
# A YAML document containing just this comment
---
# Another YAML document containing a string
a string # a trailing comment after the string
```

### Indentation is Not Optional!

YAML uses indentation to represent scope â€” that is to say, **things indented to the same level are part of the same collection or multi-line value**.

At first glance you might be worried that this could cause all sorts of weird bugs when you copy-and-paste between multiple documents â€” what if one uses tabs and the other spaces, but they look visually the same? YAML has your back thanks to a very sensible design choice **YAML forbids the use if tabs for indenting**!

## Simple Scalars in YAML

Let's start with the simplest scalar value â€” the non-value value, AKA null. YAML supports two representations for the null value â€” the keywords `null`, `Null` & `NULL`, the character `~`, or absolute emptiness, that is to say, no characters what so ever.

The next simplest scalar is the boolean, which YAML supports in a few ways:

| Boolean Value | YAML Syntax                                                  |
| ------------- | ------------------------------------------------------------ |
| True          | The keywords `true`,  `True` & `TRUE` (YAML 1.1 also allowed `Yes` & `On`) |
| False         | The keywords `false`,  `False` & `FALSE` (YAML 1.1 also allowed `No` & `Off`) |

Finally, let's look at how YAML represents numbers:

| Number Type         | YAML Syntax                                                  |
| ------------------- | ------------------------------------------------------------ |
| Integers            | `1234` or `-1234`                                            |
| Octal numbers       | Pre-fixed with `0` â€” beware, `042` and `42` are not the same thing at all! (`042` is actually `34`!) |
| Hexadecimal Numbers | Prefixed with `0x`, e.g. `0x4F` is `79`                      |
| Decimal Numbers     | `123.45`, `-123.45`, or even `12.3e+5` for scientific notation |
| Infinity            | Either `.inf` for positive infinity, or `-.inf` for negative infinity |
| Not-a-Number        | The numeric value to represent the fact that the desired value can't be represented as a number is `.NAN`. |

## Basic Strings in YAML

The first thing to note is that **all strings in YAML are Unicode**, so you can use all the accented characters and emoji you like ðŸ™‚

### String Quoting (`''` or `""`)

The second thing to note, is that unless there's some kind of contextual ambiguity, **string quoting is optional** in YAML.

In situations where you do need to quote your strings to avoid ambiguity, you need to choose between single and double quotes, and your choice is not purely aesthetic, they have different meanings! In YAML, **single quoted strings don't support escape sequences**, while **double quoted strings require escape sequences**.

In other words, the YAML string `'Hello\nWorld'` literally represents the word `Hello` followed by a backslash symbol, followed by the letter `n` followed by the word `World`, while the YAML string `"Hello\nWorld"` represents the word `Hello` followed by a newline character, followed by the word `World`.

## Collections

Now that we can represent single values, let's look at the two types of collection YAML offers.

### Sequences (Arrays/Lists)

To define what we would think of as an array in JavaScript, JSON, or jq, the basic YAML syntax is to start each entry in the array with a dash followed by a space, so we can define a simple array of mixed values with:

```yaml
---
- True
- 42
- -3.1415
- Hello World!
```

Running this through `yq` we get the following simple JSON array:

```json
[true,42,-3.1415,"Hello World!"]
```

### Mappings (Dictionaries/Objects/Hashtables)

To define what we have been referring to as dictionaries in this series, the syntax is simply keys-value pairs separated by colons `:`. For example, the following YAML document list sales data by category:

```yaml
---
Food: 365
Drinks: 432
Confectionary: 98
```

Running this through `yq` we get the following simple JSON dictionary:

```json
{
  "Food": 365,
  "Drinks": 432,
  "Confectionary": 98
}
```

### Nesting (Just Indent!)

Both sequences and mappings can contain sequences, mapings, and scalars, and you simply use indentation to define which values belong to which sequence or mapping.

As a simple example, the following YAML document defines a sequence that contain a number and another sequence containing two more numbers:

```yaml
---
- 1
- 
  - 2
  - 3
```

Running this through `yq` we get the following JSON array:

```json
[1,[2,3]]
```

This basic syntax is a little clunky for sequences of sequences, but there is an alternative syntax we'll learn later, and this basic syntax does work really well for sequences of mappings and mappings of mappings:

```yaml
---
- Day: Monday
  Sales:
    Food: 365
    Drinks: 432
    Confectionary: 98
- Day: Tuesday
  Sales:
    Food: 353
    Drinks: 392
    Confectionary: 124
---
Monday:
  Food: 365
  Drinks: 432
  Confectionary: 98
Tuesday:
  Food: 353
  Drinks: 392
  Confectionary: 124
```

Running this through `yq` we get the following  JSON array and dictionary:

```json
[
  {
    "Day": "Monday",
    "Sales": {
      "Food": 365,
      "Drinks": 432,
      "Confectionary": 98
    }
  },
  {
    "Day": "Tuesday",
    "Sales": {
      "Food": 353,
      "Drinks": 392,
      "Confectionary": 124
    }
  }
]
{
  "Monday": {
    "Food": 365,
    "Drinks": 432,
    "Confectionary": 98
  },
  "Tuesday": {
    "Food": 353,
    "Drinks": 392,
    "Confectionary": 124
  }
}
```

# YAML â€” Advanced Topics â€” EPISODE BREAK???

## Multi-Line Strings (String Blocks)

TO DO â€” figure out how the blocks below are different to basic multi-line strings.

YAML supports multiple subtly different types of multi-line strings, or, to use YAML's terminology, *string blocks*. To tell YAML that your sting will stretch over multiple lines, you pre-fix the string with a *block operator*, an optional *chomp indicator*, and a newline character.

Because indentation defines scope, and because blocks end with a newline character, YAML needs to intelligently handle both indentation and trailing newline characters, and that's where the subtle differences lie.

| String Block Operator | Syntax | Description                                                  |
| --------------------- | ------ | ------------------------------------------------------------ |
| The *block* operator  | `|`    | New line characters are preserved and the indentation at the start of every new line is ignored. **Allows multi-line strings to be indented**. |
| The *fold* operator   | `>`    | New line characters and the indentation at the start each new line are collapsed into a single space. **Allows a single line string to be written across multiple lines**. |

| Chomp Indicator              | Syntax | Description                                                  |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| The *strip* indicator        | `-`    | All trailing white space (including newline characters) is removed. |
| The default *clip* behaviour |        | When no chomp indicator is added, YAML *clips* the trailing white space by replacing it all with a single trialing newline character. |
| The *keep* indicator         | `+`    | All trailing white space (including newline characters) is retained. |

That sounds complicated, but let's look at an example YAML document that defines an array with multiple copies of the same string, each using a different combination of block operator and chomp indicator:

```yaml
---
# block operator with default clip behaviour
- |
  Hello
  World!
  
# fold operator with default clip behaviour
- >
  Hello
  World!
  
# block operator with strip chomp indicator
- |-
  Hello
  World!
  
# fold operator with strip chomp indicator
- >-
  Hello
  World!
  
# block operator with keep chomp indicator
- |+
  Hello
  World!
  
# fold operator with keep chomp indicator
- >+
  Hello
  World!
  
```

When I ran this through `yq` I got the following JSON array:

```json
[
  "Hello\nWorld!\n",
  "Hello World!\n",
  "Hello\nWorld!",
  "Hello World!",
  "Hello\nWorld!\n\n",
  "Hello World!\n\n"
]
```

Let's map those strings to the operators that produced them to better understand what happened:

| Operator | Generated String      | Explanation                                                  |
| -------- | --------------------- | ------------------------------------------------------------ |
| `|`      | `"Hello\nWorld!\n"`   | The default block behaviour is to ignore the indentation and keep just one trialing newline character. |
| `>`      | `"Hello World!\n"`    | The default fold behaviour is to collapse the newlines and the indentation into a single space, and to keep just one trailing newline character. |
| `|-`     | `"Hello\nWorld!"`     | The block operator with strip indicator ignored the indentation and all the trailing white space. |
| `>-`     | `"Hello World!"`      | The fold operator with the strip indicator collapsed the newlines and the indentation into a single space, and, stripped all the trailing white space. |
| `|+`     | `"Hello\nWorld!\n\n"` | The block operator with the keep indicator ignored only the indentation, it kept all the newline characters, including the empty line at the end of the block. |
| `|-`     | `"Hello World!\n\n"`  | The fold operator with the keep indicator collapsed the internal newline characters and indentation to single spaces, but kept all the trailing white space. |

## Flow Style Sequences & Mappings (JSON-Like)

Adding very basic arrays using the one-entry-per-line basic syntax can be tedious, this is why YAML also supports a JSON-like syntax officially known as the *flow style*. At first glance this might look just like JSON, but the syntax is much looser and much more forgiving. Unless there is some kind of ambiguity, neither key names nor strings need to be quoted, as illustrated in these example documents:

```yaml
---
{Jim Kirk: To boldy go, Jean Luc Picard: Make it so!}
---
[this is a string, so is this!]
```

Running these two documents through `yq` we get the following JSON dictionary and array:

```json
{
  "Jim Kirk": "To boldy go",
  "Jean Luc Picard": "Make it so!"
}
[
  "this is a string",
  "so is this!"
]
```

The reason we could get away without any kind of quoting is that the keys in the mapping didn't contain colons, and the strings didn't contain comas or other characters with meaning in the the flow syntax like `]` and `}`.

While you can avoid quoting surprising often, you can't always avoid it. For example, the following does not work as expected:

```yaml
---
{William Shakespear: To be or not to be, that is the question}
```

Running that through `yq` we get the following JSON dictionary:

```json
{
  "William Shakespear": "To be or not to be",
  "that is the question": null
}
```

Why? Because the coma ends the value for the key `William Shakespear` and starts a new key named `that is the question` with no value at all, which is interpreted as `null`.

The solution is of course to quote Shakespear's excerpt:

```yaml
---
{William Shakespear: 'To be or not to be, that is the question'}
```

This now converts to the expected JSON dictionary:

```json
{
  "William Shakespear": "To be or not to be, that is the question"
}
```

You can of course mix-and-match the regular and flow styles, which is in fact how you usually see the flow style used:

```yaml
---
Monday: [Mon, mon, M]
Tuesday: [Tue, tue, Tu]
Wednesday: [Wed, wed, W]
Thursday: [Thur, thur, Th]
Friday: [Fri, fri, F]
Saturday: [Sat, sat, Sa]
Sunday: [Sun, sun, Su]
---
- {Name: Bob, Emial: bob@burgers.com}
- {Name: Ken, Email: ken@barbie.com}
```

When we run this through `qy` we get the following JSON dictionary or arrays and array of dictionaries:

```json
{
  "Monday": [
    "Mon",
    "mon",
    "M"
  ],
  "Tuesday": [
    "Tue",
    "tue",
    "Tu"
  ],
  "Wednesday": [
    "Wed",
    "wed",
    "W"
  ],
  "Thursday": [
    "Thur",
    "thur",
    "Th"
  ],
  "Friday": [
    "Fri",
    "fri",
    "F"
  ],
  "Saturday": [
    "Sat",
    "sat",
    "Sa"
  ],
  "Sunday": [
    "Sun",
    "sun",
    "Su"
  ]
}
[
  {
    "Name": "Bob",
    "Emial": "bob@burgers.com"
  },
  {
    "Name": "Ken",
    "Email": "ken@barbie.com"
  }
]
```

## Using `yq` to Query YAML Files

As mentioned in the previous instalment, I used the command line tool `yq` to convert the YAML snippets in the show notes to JSON.

This tool has some very lofty goals â€” the aim being to allow any of the common data formats to be queries using the jq syntax. As we record these shows (summer 2024), `yq` implements all the commonly used features of the jq language, and it supports the most popular data formats, including YAML, JSON, XML & CSV. Work is on-going to add better TOML support, and to add support for the outstanding jq language features.

One of the things that makes this tool appealing is that it's written from the ground up in the modern Rust language, so it benefits from the secure-by-design features built into Rust, and has no dependencies!  You can get all the details on their [GitHub page](https://github.com/mikefarah/yq), and on the Mac you can install it via [Homebrew](https://brew.sh) with the command:

```sh
brew install python-yq
```

TO DO

## Final Thoughts

TO DO

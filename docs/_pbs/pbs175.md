---
title: Static Site Generators
instalment: 175
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-02-01
---
This instalment is the start of a new series-within-a-series focusing on the technology that powers this website, and, that hosts the new JavaScript version of [XKPasswd](https://www.xkpasswd.net) — GitHub Pages.

GitHub Pages provides a very interesting free web hosting option that inherently provides a full version history to easily recover from any kind of whoopsie. It's also surprisingly versatile and powerful. On one end of the spectrum you can use it to simply host a folder of HTML, CSS & JavaScript files exactly as they are, and on the other end of the spectrum you can build a full content management system with all the taxonomies and content organisation features you would expect from on a typical blog or corporate site. The mechanism GitHub Pages uses to achieve this is completely different to that used by the most popular content management system in the world, [Wordpress](https://wordpress.org), but is fundamentally the same as that used by the fashionable new up-and-comer, [Hugo](https://kinsta.com/blog/hugo-static-site/).

In this first instalment we'll set the scene, explaining the difference between dynamic content management systems like Wordpress, and static site generators like Github Pages and Hugo. We'll also give a big-picture overview of how GitHub Pages works, and hence, the technologies we'll be exploring over the coming months.

## Matching Podcast Episode

TO DO

## What Problems do Content Management Systems Solve?

Before we get lost in the weeds of the two different architectures for content management systems, let's step back for a moment and describe the problem all these systems set out to solve in their own distinct ways.

1. **Separation of content creation from content presentation**
   1. Separation at the **task** level — even if one person is running the entire site, they can easily focus on either designing it, or, creating content, they never have to wear two proverbial *hats* at once
   2. Separation at the **storage** level — regardless of how the data is stored, the content is segregated from the site's design
   3. It should be possible to change the content without needing to edit the design, and to change the design without editing the content
2. Content needs to be **organised** into sensible taxonomies, and new content should automatically appear in the correct locations within the site based on the taxonomies the creator applies. Examples of taxonomies include:
   1. Nested Page hierarchies
   2. Time-based sequences of posts or articles (blogs)
   3. Categories
   4. Tags
3. Support an **editorial process** — the details will differ from organisation to organisation
   1. Content management systems need to facilitate an organisation's desired process for creation, review, and publishing of content
   2. For personal sites or sites for small organisations the needs here may be very basic — perhaps just a mechanism for marking content as being in draft

## Two World Views — Dynamic & Static

All content management systems combine content with a theme of some kind to produce the HTML, CSS & JavaScript readers view in their browsers. The two big questions are:

1. When does the content get rendered to HTML, CSS & JavaScript?
2. Where is the content stored?

In theory these two questions are not linked, but in reality they almost always are, so we get answers to both questions with just two categories of CMS.

### Read-Time Rendering — Dynamic CMSes

More traditional CMSes like Wordpress render pages on-demand, the moment the reader would like to read them. This is done using a server-side language like PHP, and the content is stored in a relational database. 

When you visit a Wordpress site like Podfeet.com your browser sends a request to Allison's web server which then runs PHP code which reaches back to a web server Allison runs and builds the web page you requested, and returns it to your browser.

As you browse Allison's site from page to page, the same process happens again and again.

#### Pros & Cons

There is a significant amount of infrastructure needed to power a website like this:

1. A Linux or Windows server with a web server like Apache or NGINX and PHP
2. A Database server
3. The Wordpress code

The server has quite a bit of work to do on each page view, so a small number of users can make a lot of work for this infrastructure. Spikes in traffic can easily cause excessive loads on the server, so for even vaguely popular sites an additional layer of infrastructure is needed — a caching server. For this cache to be effective it needs to be tightly integrated with Wordpress so it can know when a particular post has been edited, or a new comment added, so it can invalidate it's cached copy of that page and ask the server for a fresh rendering next time a user asks for it.

Running a dynamic website involves continued bills and at least some amount of maintenance work to keep everything patched and secure.

But you do of course get some advantages:

1. Content publishes instantly
2. Content can be published at a high rate
3. User interaction like comments is natively supported
4. Authors and editors can use a web interface to manage the content

### Publication-Time Rendering — Static Site Generators

Static Site Generators like GitHub Pages turn things on their head completely. The entire site is rendered to HTML, CSS & JavaScript when new content is published, and those pre-generated files are copied to a basic web server that serves those same simple HTML files to all visitors.

Static Site Generators generally store their content in files on the file system, so there is no database, and hence no need for a database server. The web server doesn't do any rendering, so it's load is minimal, and it doesn't need any server-side languages installed at all.

The site generation of the can be done anywhere, even on your own PC, and the generated files can be moved to the server by any file-transfer protocol the server can accept.

For small sites with a single author that are not updated too often, it is perfectly practical for authors to install the SSG software on their PC, and to keep and edit their content right there. Then, when they publish a new post, to run the SSG app and drag-and-drop the updated files into their favourite secure FTP client.

This is of course not practical for multi-author sites, so the SSG can be run on a centralised server of some kind. The key requirement is that authors have a mechanism for accessing the files on that server, and that the server can run the SSG app and transfer the generated site to the web server in some way. A SAMBA file share and a few scripts to trigger a re-build and use Secure FTP to copy the files would work just fine.

These kinds of scripting approaches are simple bread and butter stuff to sysadmins, but they're not practical for home users, and, there are better tools available.

#### Git+CI/CD and Static Site Generators are a Perfect Fit!

When you stop a think about it, you have a folder of text files that multiple people need to edit in a controlled way, and where changes need to trigger actions. That's no different to writing software! 

Content creation can be done using your favourite text editor, usually in Markdown, and collaboration and editorial control can be handled by Git. No matter how complex your editorial process is, it can be implemented using Git features like branches, permissions, and pull requests.

Content publishing can then be automated using the Continuous Integration/Continuous Development (CI/CD) pipelines that are now ubiquitous in Git environments. CI/CD pipelines are effectively scripts that run in the cloud that are triggered by Git events like commits to specific branches. GitHub supports CI/CD through GitHub Actions.

This is the process by which these very show notes were published. Myself and Allison are both authors with full permissions on the Git repository for these notes, which contains a Markdown files with the content. We use a temporary Git branch to draft each new instalment, and then when we're ready to publish the instalment we merge the temporary branch into `master` which triggers a GitHub Actions action that generates and publishes the updated site.

In terms of editorial process, it's very simple — myself and Allison are peers with full publishing power, the community are contributors who use Pull Requests to submit proposed fixes and changes to us. We can then choose to accept those changes and merge them into `master` (triggering a site re-build), or we can reject them (which we almost never do).

#### Pros & Cons

The infrastructure requirements for a static site are generally simpler than those for dynamic sites. They range from simply a PC with a few apps and the most basic of web hosting to a Git + CI/CD infrastructure and a basic web server. Regardless of your scale, a static site will be architecturally simpler and cheaper to run than an equivalently sized dynamic site.

OK, so why does the whole web not run on static site generators? Because there are of course some down-sides too 🙂

1. Publication of new content is never real-time. Sure, you can automate it with triggers, but the entire site needs to be re-built each time, so it will always take a few minutes
2. User interaction needs to be off-loaded from the site — you can embed 3rd-party cloud services like Disqus, or you can simply utilise social media for audience engagement, but what ever you do, that engagement will not be tightly integrated with your CMS, it will be in some way external to it
3. While the details will vary widely, in general, the interface for authors will not be as simple and self-contained as a unified web interface. Depending on who your authors are, and what their technological experience is, that might be a bug or a feature, but regardless, it's something you need to consider carefully

### Which to Choose?

It's vital to realise that neither approach is objectively better or worse, each has advantages and disadvantages. The question is not *"which approach is best?"*, but *"which approach is best for me/us?"*. Who you are, what your goals are, and what resources you have at your disposal all need to feed into your evaluations.

Some key questions to consider:

1. What's the cadence for new content? A few posts and hour, a day, a week, a month?
2. How many readers do you need to cater for?
3. Do you want user comments embedded into your content management system?
4. What's your budget?
5. What technical skills do you have at your disposal for operating the site?
6. How are your authors with technology?
   1.  What skills do they have? 
   2. How would they feel about learning new skills? 
   3. Do they have strong feelings about tooling choices?
   4.  Are they employees you can command, or volunteers you need to attract?

At the extremes it's usually quite obvious what the right fit is. Let's take two really popular sites as examples.

First, let's consider Ars Technica — it has tens if not hundreds of authors, editors, and other contributors, new content is published many times an hour, and they integrate user comments into their pages.

It should come as no surprise that they use a dynamic system that must cost an absolute fortune to run because it needs to support a massive audience.

But now let's consider John Gruber's Daring Fireball Apple site — this is no more of a hobby project than Ars Technica, running that site puts food on John's table, but, only on John's table. He has no employees, and no complex editorial process. He publishes a handful of times a day at most, and has never allowed any kind of user-submitted content onto his site. He also has a massive audience, so he needs his site to be able to handle that load without costing him more than he can make from sponsorships.

John uses a static site generator, and it really is the perfect fit for him.

Both Ars and Daring Fireball are huge site, neither are in any way amateur, both have made the prefect technical decision for their needs, and one has opted for a dynamic site, and one for a statically generated one.

The annoying thing is that for smaller sites the tradeoffs tend to be less clear. For decades I've operated both my personal website and the site for my podcasts as dynamic sites, but I'm completely fed up with both. I'm done with managing servers and databases and paying substantial hosting bills. I want something simpler and cheaper, so I'm spending 2025 moving both of those sites to static site generators. Specifically, I'm moving both to GitHub Pages.

## Why You Might Consider Using GitHub Pages

Before we finish this instalment with a big-picture overview of how GitHub Pages works, let's just look at some reasons you might be interested in learning a little more about GitHub Pages.

1. Free web hosting 🙂 — sure, it's limited to static content, but you can use GitHub Actions with static site generators to run complex site, and, you can even use your own domains names if you like!
2. A simple way to publish documentation with any code you publish on GitHub.
3. You can host the kind of client-side web apps we've been developing in this series  without learning about Static Site Generators.
4. If you're the kind of person who's enjoying this series, your skillset and mind sets are likely to line up well with how GitHub Pages does things.

## A Big-Picture Overview of GitHub Pages

GitHub Pages converts content within a GitHub Git repository into a published web page using a somewhat customised and extended version of the open source Static Site Generator Jekyll.

GitHub Pages can directly serve HTML, CSS & JavaScript, but to make use of its content management features you need to write your content in Markdown and add your metadata as YAML front matter at the top of your Markdown files.

Some very basic aspects of GitHub Pages' operation are configured in the GitHub web interface, but most of the configuration is managed via a YAML settings file.

GitHub provides a number of built-in themes, and using the configuration file, it is possible to import other themes hosted elsewhere, including on GitHub.

To truly customise a GitHub Pages site you need to extend an existing Jekyll theme or create your own. Being an open source project, Jekyll leverages other open source technologies within it's tempting system, including:

1. The Liquid templating engine with Jinja2 filters & tags
2. The CSS pre-processor Sass

GitHub Pages in no way enforces the user of BootStrap, but given that we have relied heavily on it throughout this series, and that it's customisation features are implemented in Sass, we'll be using Bootstrap 5 with GitHub Pages in this series.

Putting it all together, you see we have a mix of technologies we're already familiar with, and some new ones:

* Git & GitHub ✅ 
  * GitHub Actions ❌
* HTML, CSS & JavaScript ✅
* Markdown ✅
* YAML ✅
* Jekyll ❌
  * Liquid Templates ❌
  * Jinja2 Tags & Filters  ❌
* Sass  ❌
* Bootstrap ✅
  * Bootstrap customisation ❌

## Final Thoughts

Our approach in this series will be to start with a Quick Look at using GitHub Pages to host a the kind of HTML+CSS+Javascript web apps we were developing earlier in this series. This use of GitHub Pages ignores Jekyll completely.

With that done we'll start on the real meat of the series — learning how to build GitHub Pages sites that do utilise Jekyll's features. We'll build this up gradually, and we'll do it in such a way that we can test our sites locally before we push our changes to GitHub to publish our sites.

Our starting point will be a simple site that uses the default theme with Bootstrap added in a customisable way.

Once we have a basic site up and running we'll look at how Jekyll supports taxonomies, and at that point we'll need to learn about Liquid and Jinja2 to fully utilise these features.

Once we can add content in an organised way, our next step will be to learn how to customise Bootstrap, and to do that we'll need to learn how Sass works.

Finally, we'll explore Jekyll themes, allowing us to understand how themes developed by others work, how to extend existing themes, and how to create our own from scratch.

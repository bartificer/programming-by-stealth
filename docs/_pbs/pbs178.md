---
title: Getting Started with Jekyll Pages
instalment: 178
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-03-15
---
TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file — [pbs178.zip](./assets/pbs178.zip) TO GENERATE

## Mini-Series House Keeping — The Demo Site for Remaining Examples

In the remainder of this series we'll be learning more about Jekyll as a Content Management System (CMS) by building a demo site that contains all the features we'll be discussing. It's going to be one site that we effectively started in the previous instalment, and each instalment will use the final state of the site at the end of the previous instalment as the starting point for all examples.

To make this as painless as possible, and to facilitate people dipping in and out at any point in the series, the site will be versioned on GitHub with tagged releases marking each instalment's starting point. As a reminder, in Git a *tag* is a human-friendly label for a specific commit,  it effectively becomes a name for a snapshot of the code at a specific point in time (for more on tagging see [Instalment 108](./pbs108)).

 This approach gives listeners three options for playing along for the remainder of this mini-series:

1. Download or fork the original repo once to start this instalment's examples, and keep that same copy current all the way through by completing each instalment in turn and testing the code locally. **This approach requires you to complete each instalment perfectly all the way through the series**, so is the simplest but the most brittle.
2. Start fresh each time by downloading the compressed version of the full codebase from the appropriately named release and then playing along for this that instalment's examples and testing locally. This approach is more laborious but less brittle.
3. Fork the repo on GitHub and pull the appropriate changes from the original (`upstream`) repo as needed, and test both locally and on GitHub Pages. This approach involves the most Git proficiency, but allows for the fullest possible experience.

You'll find the repository on GitHub as [bartificer/pbs-jekyll-demoSite](https://github.com/bartificer/pbs-jekyll-demoSite).

## Cloning an Existing Site on a New Device

Before you begin, check you have the needed Ruby environment in place on the new device by opening a fresh terminal and verifying the following:

1. That you are running the correct version of Ruby with the command `ruby --version`, that should match the version described in [instalment 177](./pbs177) (As of March 2025 that is `ruby 3.3.4`).
2. That you have Bundler installed by running the command `bundle --version`

If your environment is not prepared, follow the instructions in the section '*Preparing to Run Jekyll Locally*' in [instalment 177](./pbs177).

Once your environment is ready, clone the existing site to your device and open a terminal in that folder. Change into the folder that contains the site (probably `docs` if the site is intended for publication on GitHub Pages, so probably `cd docs`).

At the very least our current directory should now have a `Gemfile`, and it should probably also have an `_config.yml`, and an `index.md`.

All you need to do to get up and running now is to instruction Bundler to configure Ruby in your newly cloned folder based on the content of the `Gemfile` with the command:

```sh
bundle install
```

That's it! You should now be able to run your site locally with the usual `bundle exec jekyll serve` command.

### Worked Example 1 — Set Up the Starting Point for this Instalment's Examples

Get a copy of this instalment's starting point, the tagged release [pbs178-startingPoint](https://github.com/bartificer/pbs-jekyll-demoSite/releases/tag/pbs178-startingPoint), by either:

1. Downloading the zipped or Gzipped version of the full codebase at the correct point in time from the link above and extracting the contents.
2. Forking [the repository](https://github.com/bartificer/pbs-jekyll-demoSite/) on GitHub and then:
   1. Cloning your fork to your computer with your favourite Git client
   2. Checking out the commit that is tagged as `pbs178-startingPoint` (as is always the case when checking out a specific commit rather than a branch, this will result in your local repository having a *detached head*)
   3. Creating a new local branch at the newly checked out commit so you no longer have a *detached head* and can commit your work

Open your copy of the repo in your terminal, and then:

1. Change into the docs folder with the command `cd docs`
2. Initialise the Ruby setup with the command `bundle install`
3. Deploy the site locally with the command `bundle exec jekyll serve`

## Understanding Jekyll's Build Process

Fundamentally, Jekyll takes a folder of input files, processes them in some way, and creates a new folder with output files, the assembled website. Jekyll's documentation refers to a single execution of this conversion process as a  *build session*. When running a build session on local machine the entire contents of our `docs` folder is the input, and the generated website is rendered to the special folder `docs/_site`. When running a build session in the cloud, GitHub Pages takes the latest version of the `docs` folder on the `main` branch as the input, and writes the output to the GitHub Pages Content Delivery Network (CDN) to make it available on the internet.

A Jekyll build session has four distinct phases that happen sequentially:

1. **Initialise** all **plugins**, both the standard ones and those specified in the `Gemfile` as configured in `_config.yml`.
2. **Read** the files in the input folder and populate an internal data structure with that folder's content.
3. **Run** the appropriate **generators** to transform the loaded data. This step is further divided into a more detailed sequence of phases:
   1. A first *shallow pass* at **processing Liquid template tags** in all input files. This means that if processing a template triggers the inclusion of another file those inclusions are not performed yet, they are applied in the final phase of this stage.
   2. **Conversions are applied**, rendering Markdown to HTML, Sass to CSS, etc.. The conversion that gets applied is **determined by the input file's file extension**.
   3. A recursive pass through all generated HTML snippets that now exist (whether they started as HTML or were converted from Markdown) to assemble them into the final page by applying the appropriate layout to each snippet as defined by the theme. The documentation describes this process like assembling Russian nesting dolls because layouts can include other layouts can include other layouts can include other layouts …
4. **Render** the updated data structure to the output folder **using the theme's templates**

As each input file makes its way through this process, one of three things can happen to it:

1. Files can be **excluded** from the output in one of two ways:
   1. **Ignored** — these files don't appear in the output in any form. The existing content of the `_site` folder is completely ignored (and indeed destroyed!).
   2. **Absorbed** — these files don't appear directly in the output, but they do affect it in some way. Files like this can provide content or affect the look and feel of the generated site. The most clear-cut examples of such files are `_config.yml` and the entire `_layouts` and `_sass` folders.
2. Files can be **copied**, un-changed from the input folder into the generated website. The canonical examples here are images, Jekyll doesn't change them, it just copies them across.
3. Files can be **processed** so as to transform them in some way as Jekyll copies them from the input folder to the generated website. The canonical examples here are Markdown and Sass files.

Jekyll has clearly defined rules for what happens to each file, and those rules get applied based on three factors:

1. The file's extension
2. Whether or not the file contains YAML front matter (empty front matter counts as front matter)
3. Any explicit overrides defined in the site's config file (`_config.yml`)

The following is a good summary of those rules:

1. Unless explicitly overridden in the configuration, **files and folders starting with an underscore (`_`) are excluded** from the output. Unless those folder have a special meaning, they are ignored, if they have a special meaning, then their content fulfils that role. For example, using the default configuration, a file named `_waffles.txt` will get ignored, but all HTML files in the folder `_layouts` are interpreted theme layouts.
2. **Markdown files are converted to HTML**. By default, all the following file extensions get treated as Markdown files: `.markdown`, `.mkdown`, `.mkdn`, `.mkd` & `.md`.
3. All **other text files that contain front matter are processed** in some way:
   1. Files with any of the following file extensions get treated as *assets* and are processed in a special way:
      1. Files with either the `.sass` or `.scss` file extension are assumed to be Sass file and get converted to CSS using the standard [jekyll-sass-converter](https://github.com/jekyll/jekyll-sass-converter) plugin.
      2. **Optionally**, files with the `.coffee` file extension can be treated as [CoffeeScript](https://coffeescript.org) and get automatically converted to JavaScript using the optional [jekyll-coffeescript](https://github.com/jekyll/jekyll-coffeescript) plugin. **We will not be using Coffee Script in this series**.
   2. Liquid template tags are rendered (in all text files that contain front matter, including Sass & CoffeeScript files).
4. All other files are simply **copied to the output** — these files are referred to as [static files](https://jekyllrb.com/docs/static-files/) in the documentation, and `site.static_files` in Jekyll's internal data structure.

Armed with this understanding of Jekyll's rendering process, we're now ready to start adding some content to our example site.

## Adding Static Files and Assets

In the Jekyll world the word *asset* can cause confusion because it's used in multiple sections of the documentation to describe two different but somewhat related concepts — one Jekyll-specific, and one generic. Just to add to the confusion, there is also a very common convention used throughout the Jekyll community and referenced in the documentation to store files that fall under either definition of the word *asset* in a folder named `/assets` .

The generic meaning of an *asset* when building web sites is that assets are files that don't contain content, but do provide some other functionality to the site, this definitely includes CSS style sheets, JavaScript code files, fonts, icons, and UI and theme graphics. But, there are also grey areas where there is no universal agreement, and different web frameworks will encourage different conventions, and of course different developers will have differing and conflicting strongly held opinions. The greyest of grey areas are image files that are not part of the theme, but part of the content.

LEFT OFF HERE!!!

### Worked Example 2 — Add an Image to the Home Page

TO DO

## Introducing Jekyll's Simplest Taxonomy — Pages

 We're going to start with the simplest of all Jekyll's taxonomies, *pages*.

All HTML and markdown files not located in special folders are treated as *pages*. They're simply referred to as [pages](https://jekyllrb.com/docs/pages/) in the documentation, and they appear in Jekyll's internal data structure as `site.pages`.

HTML and markdown files appear in the generated site with the same relative path and file name as they did in the input folder, but always have the `.html` file extension. The Jekyll server will serve them without the need for adding any extension at all, so in effect, you should mentally thing of them as getting mapped like so:

* `index.md` or `index.html` → `https://mysite.whater/`
* `waffles.md` or `waffles.html` → `https://mysite.whatever/waffles`

When it comes to processing Liquid template tags in pages, the following simple rules apply:

1. Liquid tags get processed in all Markdown files
2. Liquid tags get processed in HTML files that have front matter (and not in HTML files that don't)

### Worked Example 3 — Add About and Recommendation Pages

TO DO

## Final Thoughts

TO DO

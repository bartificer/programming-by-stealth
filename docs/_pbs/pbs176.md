---
title: Deploying a JavaScript Web App with Webpack & GitHub Actions
instalment: 176
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-02-01
---
We're going to start the meat of our exploration of GitHub Pages by looking back slightly, and learning how to deploy a client-side, that is to say HTML+CSS+Javascript web app, on GitHub Pages using a GitHub action to bundle the dependencies with Webpack.

We've mentioned the concept of *Continuous Integration/Continuous Development*, or **CI/CD**, in passing in a few recent instalments, but only in very vague hand-waving terms. In this instalment we're finally going to dive in and implement a simple CI/CD workflow deploy a Javascript web app to a GitHub Pages site using Webpack each time a commit gets pushed to a repository's default branch.

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file — [pbs176.zip](./assets/pbs176.zip) TO UPDATE

## What is CI/CD (Continuous Integration/Continuous Deployment)?

At a philosophical level CI/CD is a model of software development where sporadic *big bang* releases are spurned in favour of a continuous stream of frequently deployed small iterative changes. The key to adopting this development mind-set is automation, and that's where CI/CD intersects with tools like GitHub. If you want to frequently deploy updated web apps, the process can't be manual and laborious, instead, it must be automated. To realise the CI/CD mindset code management platform like GitHub have developed systems for automations that are triggered by Git actions, like commits or pull requests.

In the broader world of software development CI/CD pipelines are often used to perform tasks like:

1. Automatically running a test suite against every commit or every pull request
2. Automatically applying a linter like ESLint to all source files on every commit
3. Automatically deploying code to a staging server on every commit to a specific branch
4. Automatically deploying production code on every commit to the default branch

For our purposes in this series we're going to confine ourselves to that last use-case, automating the deployment of a website each time changes are pushed to a repository's default branch.

> If you're interested in learning more about CI/CD, [the Wikipedia article on the topic](https://en.wikipedia.org/wiki/CI/CD) is a good starting point.
{: .aside}

## Introducing GitHub Actions

GitHub implements CI/CD pipelines with its [GitHub Actions](https://github.com/features/actions) feature.

Believe it or not, each time a GitHub action is triggered, GitHub creates a new virtual machine (VM) in the cloud, runs the action, and then deletes that virtual machine! This is only possible because of the magic of containerisation, which allows for extremely efficient creation and destruction of VMs.

### GitHub Actions Terminology

The GitHub docs have [a nice overview page for how GitHub Actions work](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions), but the key concepts are quite simple:

1. Individual CI/CD pipelines are referred to as **workflows**.
2. Workflows are comprised of one or more **jobs**, each of which is a sequence of **steps**.
3. Workflows are triggered by what are referred to as **events**, these are actions performed on a GitHub repository.
4. Workflows run on virtual machines referred to as **runners**, and as of January 2025 those can be Ubuntu Linux, Windows, or macOS VMs.

### Defining Workflows

Workflows are defined using YAML files in a special folder, specifically `.github/workflows`. There is an entire section of the GitHub docs dedicated to [writing workflows](https://docs.github.com/en/actions/writing-workflows).

A GitHub workflow definition consists of **YAML file defining a single top-level dictionary** with keys for the different aspects of a workflow.

The most important top-level workflow keys are:

| Workflow Key | Type                      | Description                                                  |
| ------------ | ------------------------- | ------------------------------------------------------------ |
| `name`       | String (**Recommended**)  | The human-friendly name for the Workflow in the GitHub user interface. |
| `on`         | Dictionary (**Required**) | The event or events that should trigger the workflow.        |
| `jobs`       | Dictionary (**Required**) | A dictionary defining the jobs the workflow contains. The keys for this dictionary are the alphanumeric IDs of your own choosing, and the values are dictionaries defining the jobs themselves. |
| `env`        | Dictionary (**Optional**) | A dictionary defining environment variables that will be made available within all jobs defined in the workflow. |

In terms of triggers, we're going to keep things very simple in this series, and trigger out jobs when commits are pushed to the default branch, so we'll always use the following configuration:

```yaml
on:
	push:
		branches: [ "main" ]
```

If you want to add additional triggers to your workflows, there is an entire section of the GitHub documentation dedicated to [triggering workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs).

This takes us to the most complex of the top-level keys, `jobs`. The definition for a job is itself a dictionary, with the following being the most important supported keys:

| Job Key   | Type                                                         | Description                                                  |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `name`    | String (**Recommended**)                                     | A human-friendly name for the job.                           |
| `needs`   | Array of Strings (**Optional**)                              | If a job needs another job to successfully complete before it can start, set this key to an array of one or more job IDs. |
| `runs-on` | Can be a String, but more complex definitions are possible (**Required**) | The type of VM the job should be run on.                     |
| `steps`   | Array of Dictionaries (**Required**)                         | An array of dictionaries, each defining a step. The steps will be executed in order. |
| `env`     | Dictionary (**Optional**)                                    | A dictionary defining environment variables that will be made available within all steps defined in the job. |

Again, we're going to keep things simple in this series, so we're always going to use Linux runners, so our `runs-on` definition will always be `runs-on: ubuntu-latest`.

Finally, we get to the real meat of workflows, the steps that make up a job. Each step is yet another dictionary, with the most important keys being:

| Step Key | Type                      | Description                                                  |
| -------- | ------------------------- | ------------------------------------------------------------ |
| `name`   | String (**Recommended**)  | A human-friendly name for the step.                          |
| `run`    | String                    | One or more shell commands to execute. To run multiple commands, use a multi-line string. *Use this key **or** `using`, not both!* |
| `uses`   | String                    | A valid specifier for a pre-defined action to execute with an optional but strongly recommended version number. See the documentation for [descriptions of the supported specifiers](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsuses). You can find a [listing of pre-defined actions in the GitHub market place](https://github.com/marketplace?type=actions). *Use this key **or** `run`, not both!* |
| `with`   | Dictionary                | This key provides a mechanism for passing arguments to a predefined action included via the `uses` key. The details are entirely determined by the included action, so you'll need to read that action's documentation to know what keys the action supports. *Only use this key with `uses`!* |
| `env`    | Dictionary (**Optional**) | A dictionary defining environment variables that will be made available within just this step. |

## Worked Example — Building a GitHub Actions Workflow for a WebPack-Bundled Web App

As we learned in instalments [138](./pbs138) & [139](./pbs139), to publish a web app bundled with WebPack we need to use NodeJS to import the JavaScript libraries we want to use, and then to run the WebPack command. For consistency we'll be sticking with the directory structure we used for our worked examples in those instalments, that is to say:

| File/Folder    | Description                                   |
| -------------- | --------------------------------------------- |
| `src/*`        | The source code for our web app.              |
| `docs/*`       | The built web app.                            |
| `package.json` | The NodeJS/NPM configuration for our web app. |

Rather than building a fresh example, we'll re-use the final example web app from instalment [139](./pbs139).

### Step 1 — Create a new Public GitHub Repository & Clone It Locally

Log in to GitHub and [create a new repository in the usual way](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository). If you want to be able to experiment with GitHub Actions and GitHub Pages for **free** you'll need to make it a **public repository**.

Once you've created your example repository, clone it to your personal computer as you usually would, and open a command prompt in that folder.

### Step 2 — Add the Web App Code & NodeJS/NPM Configuration

Extract the contents of the Instalment ZIP file and copy all the files and folders into your cloned repo. Rename the file `_gitignore` to `.gitignore` and then commit everything as the initial code.

With the initial code committed, let's manually build the web app so we can see what it is we are trying to automate. Before continuing, **make sure you have the latest NodeJS installed** (or at least the latest LTS version)!

In the command prompt you have open in your cloned copy of the repo, start by initialising NodeJS with the command:

```sh
npm ci
```

_**Reminder:** this command does a 'clean install', downloading the exact versions of the each package listed as required in `package.json` as recorded in `package-lock.json`._

Before going any further, open the placeholder file `docs/index.html` in your browser.

Now, let's try build our web app with command:

```sh
npm run build
```

This will build our web app using the source code in `/src` as specified by the Webpack configuration in `webpack.config.js` using the build command defined in `package.json`.

Refresh your browser and you should see the placeholder has been replaced with the same dummy web app we built at the end of instalment 139.

**Discard all changes in your clone of the repo.**

### Step 3 — Add a GitHub Actions Workflow to (re)Build the Web App on each Commit

TO DO — LEFT OFF HERE!!!

### Step 4 — Enable GitHub Pages to Server the App

TO DO

## Final Thoughts

TO DO

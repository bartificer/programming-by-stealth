---
title: Deploying a JavaScript Web App with Webpack & GitHub Actions
instalment: 176
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-02-01
---
We're going to start the meat of our exploration of GitHub Pages by looking back slightly, and learning how to deploy a client-side, that is to say HTML+CSS+Javascript web app, on GitHub Pages using a GitHub action to bundle the dependencies with Webpack.

We've mentioned the concept of *Continuous Integration/Continuous Development*, or **CI/CD**, in passing in a few recent instalments, but only in very vague hand-waving terms. In this instalment we're finally going to dive in and implement a simple CI/CD workflow deploy a Javascript web app to a GitHub Pages site using Webpack each time a commit gets pushed to a repository's default branch.

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file — [pbs176.zip](./assets/pbs176.zip) TO UPDATE

## What is CI/CD (Continuous Integration/Continuous Deployment)?

At a philosophical level CI/CD is a model of software development where sporadic *big bang* releases are spurned in favour of a continuous stream of frequently deployed small iterative changes. The key to adopting this development mind-set is automation, and that's where CI/CD intersects with tools like GitHub. If you want to frequently deploy updated web apps, the process can't be manual and laborious, instead, it must be automated. To realise the CI/CD mindset code management platform like GitHub have developed systems for automations that are triggered by Git actions, like commits or pull requests.

In the broader world of software development CI/CD pipelines are often used to perform tasks like:

1. Automatically running a test suite against every commit or every pull request
2. Automatically applying a linter like ESLint to all source files on every commit
3. Automatically deploying code to a staging server on every commit to a specific branch
4. Automatically deploying production code on every commit to the default branch

For our purposes in this series we're going to confine ourselves to that last use-case, automating the deployment of a website each time changes are pushed to a repository's default branch.

> If you're interested in learning more about CI/CD, [the Wikipedia article on the topic](https://en.wikipedia.org/wiki/CI/CD) is a good starting point.
{: .aside}

## Introducing GitHub Actions

GitHub implements CI/CD pipelines with its [GitHub Actions](https://github.com/features/actions) feature.

Believe it or not, each time a GitHub action is triggered, GitHub creates a new virtual machine (VM) in the cloud, runs the action, and then deletes that virtual machine! This is only possible because of the magic of containerisation, which allows for extremely efficient creation and destruction of VMs.

### GitHub Actions Terminology

The GitHub docs have [a nice overview page for how GitHub Actions work](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions), but the key concepts are quite simple:

1. Individual CI/CD pipelines are referred to as **workflows**.
2. Workflows are comprised of one or more **jobs**, each of which is a sequence of **steps**.
3. Workflows are triggered by what are referred to as **events**, these are actions performed on a GitHub repository.
4. Workflows run on virtual machines referred to as **runners**, and as of January 2025 those can be Ubuntu Linux, Windows, or macOS VMs.

### Defining Workflows

Workflows are defined using YAML files in a special folder, specifically `.github/workflows`. There is an entire section of the GitHub docs dedicated to [writing workflows](https://docs.github.com/en/actions/writing-workflows).

A GitHub workflow definition consists of **YAML file defining a single top-level dictionary** with keys for the different aspects of a workflow.

At the very least your workflow needs the following top-level keys:

| Workflow Key | Type       | Description                                                  |
| ------------ | ---------- | ------------------------------------------------------------ |
| `name`       | String     | The human-friendly name for the Workflow in the GitHub user interface. |
| `on`         | Dictionary | The event or events that should trigger the workflow.        |
| `jobs`       | Dictionary | A dictionary defining the jobs the workflow contains. The keys for this dictionary are the alphanumeric IDs of your own choosing, and the values are dictionaries defining the jobs themselves. |

In terms of triggers, we're going to keep things very simple in this series, and trigger out jobs when commits are pushed to the default branch, so we'll always use the following configuration:

```yaml
on:
	push:
		branches: [ "main" ]
```

If you want to add additional triggers to your workflows, there is an entire section of the GitHub documentation dedicated to [triggering workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs).

This takes us to the most complex of the top-level keys, `jobs`. The definition for a job is itself a dictionary, and at the very least that dictionary needs the following keys:

| Job Key              | Type                                           | Description                                                  |
| -------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `name`               | String                                         | A human-friendly name for the job.                           |
| `needs` **optional** | Array of Strings                               | If a job needs another job to successfully complete before it can start, set this key to an array of one or more job IDs. |
| `runs-on`            | String (more complex definitions are possible) | The type of VM the job should be run on.                     |
| `strategy`           | Dictionary                                     | TO FIGURE OUT                                                |
| `steps`              | Array of Dictionaries                          | An array of dictionaries, each defining a step. The steps will be executed in order. |

Again, we're going to keep things simple in this series, so we're always going to use Linux runners, so our `runs-on` definition will always be `runs-on: ubuntu-latest`.

TO DO — describe the strategy

Finally, we get to the real meat of workflows, the steps that make up a job. Each step is yet another dictionary, with the most important keys being:

| Step Key | Type | Description |
| -------- | ---- | ----------- |
| TO DO    |      |             |

## Final Thoughts

TO DO

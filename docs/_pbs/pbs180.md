---
title: Jekyll Layouts
instalment: 180
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-05-24
---

In [the previous instalment](./pbs179) we learned the basics of how the Liquid templating language works within Jekyll. Because of our existing knowledge we demonstrated how Liquid can be used within Markdown files in Jekyll sites, but while that is useful, it's not actually Liquid's most common use within Jekyll. So what is the most common use for Liquid objects and tags in a Jekyll site? The definition of a Jekyll site's theme, and that's going to be focus of this instalment.

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file â€” [pbs180.zip](./assets/pbs180.zip) TO UPDATE

## What's the Problem to be Solved?

The markdown files that contain a Jekyll site's contents only contain the contents, they don't contain any of the other things you expect to see on a web page like some site-related branding, navigation bars, or footers. So the obvious question is how those kinds of things get added? The answer is that the content in your files gets wrapped by pre-defined *layouts* (to use the correct Jekyll jargon) which are HTML files containing Liquid objects and tags. 

## Understanding Jekyll Theming

In Jekyll theming is a rather loosely defined concept. There is no folder called `_theme` where the entire theme is contained, instead, the HTML that gets wrapped around the Markdown is determined by two things:

1. The *layouts* the site defines
2. The assets referenced in the layouts
3. The re-usable snippets referenced in layouts

Note that we won't be covering re-usable snippets in this instalment, that will be the focus of our next instalment, so we'll park those for now.

By assets we mean the images, style sheets and JavaScript files referenced in the HTML in the layouts. These assets are treated like regular files by Jekyll so they don't have an enforced location. However, there is a well established convention of collecting the assets together into a top-level folder named `assets`, and that's a convention we'll be following in this series. TO DO â€” refer back to other earlier instalment where we discussed assets.

When it comes to the layouts themselves, they are a new concept to us, and I like to think of them as being like Russian nesting dolls â€”  the result of converting your Markdown to HTML is the smallest doll, and that doll gets wrapped with one or more layouts to build the final HTML web page saved to the output folder.

Note my use of the word *wrap* â€” this is the word the Jekyll documentation uses, and it's the right way to think about how Jekyll sites get themed. Unlike assets, there is a very rigid rule

## How Jekyll Layouts Work

Firstly, there is always a default layout, and if nothing tells Jekyll to use a different layout, then your page's content will get wrapped by that default layout.

So where does the default layout come from? Jekyll looks for a file named `default.html`, and it tries the following locations, in the following order until it finds one:

1.  `_layouts/default.html` in your input folder
2. `_layouts/default.html` in the theme specified in the site configuration, if there is one
3. `_layouts/default.html` own the default theme

For now, we will be working entirely within our current site, **so we'll define all our layouts**, including our default layout, **in the `_layouts` folder** in our input folder (`docs` in our example site).

Layout files are just plain old HTML pages containing Liquid objects and liquid tags.

Since layouts are designed to wrap content, they use the Jekyll-specific Liquid variable `content` to insert the content they are wrapping. In other words, at the point in your layout that you want the HTML version of your Markdown to appear, you add the Liquid Object `{% raw %}{{ content }}{% endraw %}`.

The simplest layout would simply be:

{% raw - %}
```html
<html>
  <body>
    {{ content}}
  </body>
</html>
```
{%- endraw %}


### Specifying Layouts

Layouts are always specified with base-name of HTML file that defines them, e.g. the layout `front_page` will always be defined by the file `front_page.html`. Jekyll decides on which `front_page.html` file to use based on the same rules described above for the default layout, that is to say:

1. The site's own `_layouts` folder (what we will be doing for now)
2. The site's theme, if one is specified (we are not specifying one ATM)
3. The default theme

There is no limit to how many layouts you create, and each page can be rendered by any layout. Jekyll chooses the layout file to go looking for by checking for the following metadata in the following order:

1. A front matter entry named `layout`
2. A taxonomy-level default layout (we'll be ignoring this feature for now since we're only using the basic *Pages* taxonomy ATM)
3. The default layout (`default.html`)

As a practical example, if we assume we have created a special layout for the home page and saved it as `_layouts/front_page.html`, then we would specify it's use by expanding the front matter in our `index.md` file to specify our layout like so:

```yaml
---
title: Home
layout: front_page
---
```



### Nesting Layouts

To avoid confusion as to how this works, I suggest avoiding thinking of layouts inheriting from each other, and instead think of nested layouts â€” yes, back to our Russian Nesting Dolls metaphor.

The inner-most doll is the HTML generated by the markdown conversion, and that HTML will always be wrapped by a layout, either the default, or one specified in the front matter or the site's configuration. **Every layout has the option to use its front matter to specify that the output it creates should be wrapped in another layout**.

If we continue out hypothetical example from above and image that we want our `front_page` layout specified in `index.md` to add a little content around the result of converting `index.md` to HTML before wrapping all that with the default layout we would add the following front matter to the top of `_layouts/front_page.html`:

```yaml
---
layout: default
---
```

This would give us three nested proverbial dolls â€” the markdown converted to HTML as the inner doll, the extra HTML wrapped around that by the `front_page` layout as the middle doll, and the HTML wrapped around all that by the default theme as the final outer doll.

In other words, our page specifies a layout that specifies another layout.

### Liquid Variables within Layouts

Firstly, Jekyll's standard `site` dictionary is available for use in all layouts.

Secondly, because layouts are always invoked to convert a specific markdown file to HTML, there is always the concept of a *current page*, so layouts can access all the keys in the dictionary Jekyll builds to describe the current page, `page`. This dictionary contains a combination of information collected by Jekyll, and all the keys in the markdown file's front matter. Some useful data in this dictionary includes `page.title` for the page's title, and `page.url` for the part of the page's final URL after the domain name. The [Jekyll documentation on variables](https://jekyllrb.com/docs/variables/) gives a full description.

Note that when we move on to look at more advanced taxonomies the `page` dictionary will become a lot more useful to us than it is now.

Finally, Liquid tags and objects within layout files have access to the Jekyll provided variable `layout` which is a dictionary containing just the keys defined in the layout file's front matter.

So, in short, the Liquid objects and tags within a layout file can use:

* `content` to access the content that should be wrapped.
* `layout` to access any front matter defined within the layout itself.
* `page` to access page-specific metadata including any front matter added to the top of the page.
* `site` to access the site-specific data including all keys added to the site's `config_yml` file.

## Some Important Liquid Filters when Designing Layouts

Firstly, a reminder that if you want your site to work relaiably both locally and when published to GitHub Pages, you need to filter all URLs inserted via Liquid objects with the `relative_url` filter.

TO EXPAND

- `inspect` to convert a variable to a string for debugging.
- `sample` to grab one or more random items from a list
- `sort`
- `normalize_whitespace` for dealing with odd spacing in strings.
- `smartify` for converting plain quotation marks to matching fancy angled ones.
- `markdownify` for converting a Markdown string to an HTML string (potentially confusing name!)
- `array_to_sentence_string` for converting lists of strings to human-friendly lists
- `uri_escape` for handing special characters in a full URL and `cgi_escape` for handling special characters in a single query string parameter.

## Worked Example 1 â€”  Explaining our Current Bootstrap 5 Default Layout

From the start of our exploration of Jekyll we've been using a very basic layout that loads Bootstrap 5, wraps our content in some appropriate HTML 5 tags, and inserts a header at the top of all pages. Up until this point I've asked you to indulge me by simply accepting the content of `_layouts/default.html` as *magic sauce* on the promise that we would explain how it actually works later. Well, now we've now learned enough to do just that, so let's get stuck in ðŸ™‚

If you'd like to play along, our starting point will be our demo site as we left it at the end of the previous instalment. You can [download a snapshot of the site at the appropriate commit here](https://github.com/bartificer/pbs-jekyll-demoSite/releases/tag/pbs180-startingPoint), or you can clone the repo and checkout the commit with the tag `pbs180-startingPoint`.

Because I wanted to start with as simple a demo site as possible, the site only has one layout ATM, the default layout, which is defined in `_layouts/default.html` in our site's input folder, i.e. `docs`. Here's the content of that file as it stands at this point in the series:

{% raw -%}
```html 
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ page.title }} | {{ site.title }}</title>
  <link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">
</head>
<body>
<main class="container pt-3">
    {{ content }}
</main>
<script src="{{ '/assets/js/bootstrap.bundle.min.js' | relative_url }}"></script>
</body>
</html>
```
{%- endraw %}

For the most part you'll regognise this as the standard HTML 5 page structure as recommended in the Bootstrap documentation. But it contains five Liquid objects.

The first two set the window/tab title for pages to the page's title as read from the `page.title` Liquid variable followed by a pipe, followed by the site's title as read from the `site.title` variable.

Note that  `page.title` is loaded from the front matter in the current markdown file. If you look at the front matter in, say, `about.md` you'll see it says:

```yaml
---
title: About
---
```

The rule is that all page metadata provided by Jekyll and all front matter defined at the top of the page are made available via the `page` dictionary, so `title` in a page's front matter become `page.title` in Liquid.

Similarly, the values defined in `_config.yml` are merged with the site-level metadata provided by Jekyll into the `site` variable, so the following line from the top of `_config.yml` defines `site.title`:

```yaml
title: PBS Jekyll Demo Site
```

The third Liquid object inserts the Bootstrap 5 style sheet converted to standard CSS from Bootstrap's SASS source code by Jekyll. I want to remind you of two things; firstly the source file for `/assets/css/style.css` is `/assets/css/style.scss` â€” when Jekyll converts the file from SASS to CSS it also changes the file extension. And secondly, this is relative URL, so we must filter it with the `relative_url` filter.

The third Liquid object inserts the special variable `content` â€” this variable holds the page's content converted from markdown to HTML by Jekyll. This is where we inject the content to be wrapped by the layout.

Finally, we use another Liquid object with the `relative_url` filter to include the Bootstrap 5 JavaScript.

For now, that's all there is to our very simple starter layout, and indeed, our very simple started theme as a whole! Our entire demo site theme currently consists of the Bootstrap SASS source code, the bundled Bootstrap JavaScript code, and a default layout consisting of just 15 lines of HTML code with just five Liquid objects making use of just one three Liquid variables and one Liquid filter. There's not even a single Liquid tag used yet!

## Worked Example 2 â€” Creating a Custom Layout for our Front Page

TO DO

## A challenge â€” Add a Navigation Bar to the Default Theme

TO DO

## Final Thoughts

Learning how to nest layouts is very powerful, and simply understand that principle opens many doors, enabling sufficient theming for basic sites. However, to really get the most out of Jekyll we need to learn a related concept â€” re-usable HTML snippets that can be added to multiple themes, and even into our content to facilitate features Markdown can't handle natively like the use of `<figure>` tags to add images with captions. We'll dedicate the next instalment to learning about the Jekyll *includes* which are implemented using the `include` Liquid tag, often with the help of another powerful Liquid tag,  `capture`.

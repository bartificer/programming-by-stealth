---
title: Jekyll Includes
instalment: 181
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-05-24
---

TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file — [pbs181.zip](./assets/pbs181.zip) — TO UPDATE

## PBS 180 Challenge Solution

The challenge set at the end of [the previous instalment](./pbs180) was to add a Bootstrap 5 nav bar that lists your site's pages to the top of every page on your site. The idea is to give quick access to any page from any other page.

For your convenience, you can quickly access my sample solution by [downloading a snapshot of the demo site at the appropriate commit here](https://github.com/bartificer/pbs-jekyll-demoSite/releases/tag/pbs180-challenge-startingPoint), or you can clone the repo and checkout the commit with the tag `pbs180-challenge-solution`.

Because the challenge was to add the nav bar to all pages, the only file I needed to update was the default layout, which is `_layouts/default.html` in our site's input folder (`docs`). Here's the full updated file:

```html
{% raw %}<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ page.title }} | {{ site.title }}</title>

  {%- comment %}Include Bootstrap 5 compiled CSS{% endcomment %}
  <link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">
</head>
<body>
  <div class="container">
    {%- comment %}The page header region{% endcomment %}
    <div class="row">
      <header class="col-12 my-3">

        {%- comment %}The navigation bar arcross the very top of the page{% endcomment %}
        <nav class="navbar navbar-light bg-light navbar-expand-sm rounded-pill border border-1">
          <div class="container-fluid">

            {%- comment %}The site branding part of the nav bar{% endcomment %}
            <a class="navbar-brand" href="{{ '/' | relative_url }}">{{ site.title }}</a>

            {%- comment %}The expand toggle that will appear on the right of the nav bar when the navigation below is collapsed{% endcomment %}
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>

            {%- comment %}The collapsing list of pages{% endcomment %}
            <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
              <div class="navbar-nav">
                {%- assign nav_pages = site.html_pages | where_exp: "item", "item.title != 'Home'" %}
                {%- for p in nav_pages %}
                <a class="nav-link {%- if p.url == page.url %} active{% endif %}" {%- if p.url == page.url %} aria-current="page"{% endif %} href="{{ p.url | relative_url }}">{{ p.title }}</a>
                {%- endfor %}
              </div>
            </div>
          </div>
        </nav>
      </header>
    </div>

    {%- comment %}The main content region{% endcomment %}
    <div class="row">
      <main class="col-12">
        {{ content }}
      </main>
    </div>
  </div>

  {%- comment %}Include Bootstrap 5 JavaScript{% endcomment %}
  <script src="{{ '/assets/js/bootstrap.bundle.min.js' | relative_url }}"></script>
</body>
</html>{% endraw %}
```

At first glance this file has expanded **a lot** but that is a little deceptive because a lot of the new lines are blank lines for better spacing, and the addition of comments to explain the page structure.

Bootstrap 5 Navbars require quite complex markup, so this seemed the opportune time to add comments to the file. Also, this gave me a good opportunity to introduce Liquid comments and explain why you might choose to use them over HTML comments.

### A Note on Liquid Comments

You can add comments to both your Jekyll layouts, and your site's content files using Liquid comment tags These are parts of lines or multiple lines wrapped with {% raw %}`{% comment %}` and `{% endcomment %}`{% endraw%}. Nothing between the opening and closing tags will appear in the generated website's files. **Liquid objects and tags within Liquid comments are ignored**, so you can use them to temporarily deactivate parts of your files while debugging problems.

Liquid comment tags support Liquid's while-space control syntax (`-` signs on the insides of delimiters [as described in the core Liquid docs](https://shopify.github.io/liquid/basics/whitespace/)), this means **you can simultaneously add spacing lines and useful information** for your future self **to your source files without either being visible in the generated HTML**!

To understand this, let's focus on just one small snippet from the top of the updated default theme:

```html
{% raw %}<title>{{ page.title }} | {{ site.title }}</title>

{%- comment %}Include Bootstrap 5 compiled CSS{% endcomment %}
<link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}">{% endraw %}
```

The `-` symbol to cuddled the left of the opening delimited for the opening `comment` tag ({% raw %}`{%-`{% endraw %}) tells Jekyll when it renders the page it should erase all white space to the left of the opening `comment` tag, in other words to *delete the preceding blank line*.

This means that these four lines of HTML+Liquid in the default layout appear in the generated HTML files as simply:

```html
<title>About | PBS Jekyll Demo Site</title>
<link rel="stylesheet" href="/pbs-jekyll-demoSite/assets/css/style.css">
```

With that little note on comments out of the way, let's look at how my sample solution actually works!

### How the Sample Solution Works

If you look at the front matter at the top of the regular site pages (`about.md` and `links.md`) you'll see they don't specify a layout, so that means they are using `_layouts/default.html`. At the top of the home page (`index.md`) the front matter does specify a layout, it specifies `home_page`, so that means the first layout that will be wrapped around the home page is `_layouts/front_page.html`. However, if you look at the top of `_layouts/front_page.html` you'll find that it also specifies a layout, specifically, `default`, so that means that the home page's gets wrapped twice, once by `_layouts/front_page.html`, and then again by `_layouts/front_page.html`. So, anything we add to the top of `_layouts/front_page.html` will appear at the top of every single page. Clearly, that is the file we need to add our nav bar to.

The nav bar need to be within the body of the page, and, it needs to be inside the top-level Bootstrap container, so it needs to be somewhere within `<html> → <body> → <* class="container">`.

When starting this challenge the page had an extremely simplistic structure — the container tag was at the HTML 5 semantic tag `<main>` and, it all the content was contained within that tag.

When there was no nav bar this was semantically correct, because each page contained **only** content, and the correct semantic tag for a page\'s content is `<main>`. But a nav bar is not part of a page's content, it is part of each page's visible header region, so the appropriate semantic tag for containing the nav bar is `<header>`.

So, semantically we need to end up with our content still in a `<main>` tag, and our new nav bar in a new `<header>` tag, and all of that somehow contained in a valid Bootstrap 5 layout. What we need then is a two-row Bootstrap 5 grid layout with one full-width column in each row. The way I chose to accomplish this is with the following top-level structure:

```html
<html>
<body>
  <div class="container">
    <div class="row">
      <header class="col-12 my-3">
        <!-- NAV BAR HERE -->
      </header>
    </div>
    <div class="row">
      <main class="col-12">
        <!-- CONTENT HERE -->
      </main>
    </div>
  </div>
</body>
</html>
```

_**Note:** If you've gotten a little rusty when it comes to Bootstrap grid's layout system, [here's the relevant documentation](https://getbootstrap.com/docs/5.3/layout/grid/)._

For the nav bar itself the first thing to remember is that the correct semantic tag for a navigation element is `<nav>`, so what ever cool Bootstrap feature's we'll use, the tag that shout contain it all should be a `<nav>`.

To implement the navigation bar I leaned very heavily on the [Bootstrap 5 documentation for nav bars](https://getbootstrap.com/docs/5.3/components/navbar/) because my own Bootstrap had gotten quite rusty!

I chose to use a nav bar that could collapse so I could make it responsive on small screens, and I chose to use just two components (ignoring the hamburger button for expanding and collapsing the bar on small screens) — a text-only brand heading, and a flat list of links in a basic nav.

By combining those choices with the documentation I devised the following big-picture structure:

```html
<nav class="navbar navbar-light bg-light navbar-expand-sm rounded-pill border border-1">
  <div class="container-fluid">
    <a class="navbar-brand">SITE BRAND LINKING TO HOME PAGE HERE</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse">
      <div class="navbar-nav">
        PAGE LINKS HERE
      </div>
    </div>
  </div>
</nav>
```

Let's break that down a little. To make any `<nav>` be a Bootstrap 5 nav bar it needs the class `navbar` at the very least. To give it a useful colour I added the class `bg-light` (specifying a light background), and because I wanted it to stand out a bit I added a 1px border with the classes `border` and `border-1`, and because I don't like sharp edges, I made it pill-shaped with the class `rounded-pill`. Finally, to specify that I want the nav bar to collapse at the very smallest size (`xs`), but to expand for all other sizes, I added the class `navbar-expand-sm` to specify that it should expand itself into a normal bar without a hamburger for all sizes bigger than extra small, i.e for sizes `sm` and above.

Next, to add more than a single thing into the nav bar and have it display nicely, all the content needs to be wrapped on a fluid container, hence the `<div class="container-fluid">` directly inside the `<nav>` and wrapping everything else.

The first thing in the bar, starting form the left, will be the brand, hence, the first child within the fluid container is a link with the class `brand` that I'm going to make link to the front page and have the site's title as its text.

The docs explicitly say that if you want a collapsible bar, the second child **must** be the hamburger button that will only be visible on the sizes below the expansion size specified with an `navbar-expand-*` class, hence the `<button class="navbar-toggler">` containing the `<span class="navbar-toggler-icon">` that becomes the hamburger icon when needed.

The last child is the container to wrap what ever it is that will be expanded on most screens but collapsed on phone screens, which goes in the `<div class="navbar-collapse">`. Note that this div must have an `id`, and that ID **must** match both the Bootstrap data attribute `data-bs-target="#SOME_ID"` and the accessibility attribute `aria-controls="SOME_ID"` for the hamburger button to work correctly when the nav is collapsed. I chose to use the ID `navbarNavAltMarkup`, so hence the matching tags:

```html 
<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">…</button>
…
<div class="collapse navbar-collapse" id="navbarNavAltMarkup">
```



Finally, the links we want to be expanded most of the time but collapsed on phone screens go into a  `<div class="navbar-nav">`.

OK, so that explains the HTML 5 semantic tags, and the Bootstrap 5 tags and classes, the final piece of the puzzle is the Liquid objects and tags for inserting the two piece of content — the brand link, and the list of page links.

To add the brand link we need two liquid objects (placeholders) to inject the details for the `<a class="nav-brand">` tag — one to add the URL inside an `href=""` attribute, and one to add the site's title within the tag's content:

```html 
{% raw %}<a class="navbar-brand" href="{{ '/' | relative_url }}">{{ site.title }}</a>{% endraw %}
```

The link is simply the correctly filtered relative URL `/`, and the text is the site's `title` property which is available via the Liquid variable `site` (which is a dictionary).

Finally, we need a loop to add links to every page but the current home page. We've already seen that we get the list of all HTML pages from the Liquid variable `site.html_pages`, that we can filter out the home page with a `where_exp` filter, and then save the result into a new with the name of our choice using a Liquid `assign` tag. I chose to use the variable name  `nav_pages`, hence this line to gather the information before the loop:

```html
{% raw %}{%- assign nav_pages = site.html_pages | where_exp: "item", "item.title != 'Home'" %}{% endraw %}
```

Now that our list of pages to link to is in the `nav_pages` variable we can loop over them with a Liquid `for` tag of the form:

```html
{% raw %}{%- for p in nav_pages %}
CODE FOR LINK HERE
{%- endfor %}{% endraw %}
```

To add the link we need to construct an `<a class="nav-link">` tag with the correctly filtered relative URL to the page as the `href=""` property and the page's title as the tag's content. We could do that with the simple line:

```html
{% raw %}<a class="nav-link" href="{{ p.url | relative_url }}">{{ p.title }}</a>{% endraw %}
```

But for a little added flare, I wanted to mark the current page as being the current page using the Bootstrap 5 class `active` and the accessibility property `aria-current="page"`. To do that I needed to use two Liquid `if` tags to insert the class and the accessibility property on just the nav bar link for the current page. The key to that is to find a condition that is only true for that one link in the list. The URL of the link being rendered is `p.url`, and the Liquid variable `page` always represents *the current page*, so the needed condition is simply `p.url == page.url`. Putting it all together I get the final line:

```html
{% raw %}<a class="nav-link {%- if p.url == page.url %} active{% endif %}" {%- if p.url == page.url %} aria-current="page"{% endif %} href="{{ p.url | relative_url }}">{{ p.title }}</a>{% endraw %}
```

Having explained all this in great detail it's worth stepping back a moment to take stock of how much of this challenge was blowing the dust off skills from much earlier in this series, and how much was actually new to us and related to Jekyll/Liquid:

1. We had to refresh our memory on the HTML 5 semantic tags `<main>`, `<header>`, and `<nav>`.
2. We had to refresh our memory of Bootstrap 5 grid layouts
3. We had to refresh our memory of Bootstrap 5 nav bars
4. We had to test-drive our new understanding how Jekyll layouts are used to wrap the content in our Markdown files. 🆕
5. We had to test-drive our new understanding of Liquid objects (placeholders), the Liquid tags `assign`, `for`, and `if`, and the Liquid filter `relative_url`. 🆕 

So, only a small fraction of the challenge solution is actually new ground, most is actually a refresher on previously exposed concepts.

## Re-usable Snippets with Jekyll Includes

In the previous instalment we learned how Jekyll layouts are used to define the HTML that goes around our content. We described how layouts can be nested into a Russian Nesting Doll-like structure with the original content wrapped in a layout wrapped in a layout, etc.. This simple structure provides the bulk of the theming on typical Jekyll sites, but it's not quite sufficient to cover all needs. That's why Jekyll also support re-usable snippets that can be re-used in multiple files.

These re-usable snippets, or *Jekyll includes* to give them their proper name, can be used **both** within layouts **and** content files.

Rather than try to explain their use in the abstract, we're going to use worked examples to discover both how they work and why they are useful.

### How Jekyll Includes Work

To include a re-usable snippet in another file you first need to create the snippet. These are simply files saved in the special folder `_includes`. The `include` Liquid tag is used to include a snippet in a file, the basic syncs is simply:

```html
{% raw %}{% include SOME_FILE.SOMETHING %}{% endraw %}
```

The file path specified in the `include` tag is interpreted as being relative to the `_includes` folder.

The file path in the `include` tag can contain Liquid objects (placeholders), and the snippets themselves can also contain Liquid objects and tags.

You can even pass variables into snippets by adding `key = 'Value'` attributes after the path in your `include` tags (we'll see this in action later).

## Worked Example 1 — Facilitating Non-Nesting Layouts with Includes

When we last left our demo site after the challenge described earlier, the front page was different from every other page, having it's own custom layout, but that layout was wrapped within the default layout, so we were able to customise the home page without duplicating the standard CSS and JavaScript includes that are needed on every page on our site.

Now, let's update the site to use a completely different layout for the home page, one that inherits none of the default layout's standard structure. To do this we'll need to create a layout that does not ask to be wrapped in the default layout. But, that means our new home page layout won't automatically inherit the standard CSS  and JavaScript includes already defined in the default theme.

We could duplicate these parts of the page in our new layout, but then if we ever needed to change the standard CSS or JavaScript includes we'd have to remember to make our change in two places or we'd trigger a bug. There must be a better way!

Of course there is, we need to move the CSS and JavaScript stuff into re-usable snippets, and then re-use those same snippets in **both** the default layout and our new layout.

LEFT OFF HERE!!!

## Worked Example 2 — Using Includes to for Advanced Image Markup

For such a simple syntax is really is amazing how much of a document's content can be capture with pure Markdown. However, Markdown has some weaknesses, and one of them is its representation of images. Markdown's syntax includes support for basic images that have a source URL, title, and alternative text, but there is no way using pure Markdown to define a figure, that is, an image with a caption.

We can define a re-usable snippet that takes three arguments to add support for figures to our content with a Jekyll include.

The three arguments we need are:

1. The image's path
2. The alternative text for the image
3. The image's caption

TO DO

## Passing Large Arguments to to Includes with the `capture` Tag

TO DO

## A challenge — TO DEVISE

TO DO

## Final Thoughts

TO DO

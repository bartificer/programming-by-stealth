---
title: Introducing Liquid Templates
instalment: 179
miniseries: GitHub Pages
creators: [bart, allison]
date: 2025-05-10
---

We ended the previous instalment with a teaser ‚Äî we'd just hard-coded a list of our site pages on the home page, and realised that surely can't be the right thing to do!

In this instalment we learn to do this simple task the right way ‚Äî using Jekyll's support for the Liquid templating engine.

## Matching Podcast Episode

TO DO

## Instalment Resources

- The instalment ZIP file ‚Äî [pbs179.zip](./assets/pbs179.zip) ‚Äî TO UPDATE

## What's the Problem to be Solved?

When building sites with a static site generator like Jekyll you need a mechanism for injecting information into the otherwise static source files using some kind of place-holders. That could be site-wide information like a list of all pages that exist, page-specific information like the date it was published, theme-specific information, or some other form of data being added to the site. In short, static site generators need some kind of templating engine, and rather than inventing their own, the Jekyll developers chose to use an existing open source templating engine, [Liquid](https://shopify.github.io/liquid/).

## Some Background on Liquid

Liquid was developed as part of the very first release of the [Shopify](https://www.shopify.com/) e-commerce platform, and was released as open source immediately. It remains in use today as the templating engine used to customise customer stores on the Shopify platform.

There are in effect three variants of Liquid ‚Äî
there is the open source core which the other variants build on, and which anyone can use in any generic context. And then there are dedicated variants for Liquid's two mistnprominent usages ‚Äî a variant for Shopify, and another for Jekyll. These both extend the core by adding additional application-specific features.

I mention this detail because it can be really helpful when interpreting search results!

There are the official documentation links for the two flavours that are relevant for our use:

* **The Core Liquid Docs:** [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/) (we can use all the features described here for the specific version of Liquid included in our specific install of Jekyll)
* **The Jekyll Extensions to Liquid:** [jekyllrb.com/‚Ä¶](https://jekyllrb.com/docs/liquid/)

Finally, when you use Jekyll with GitHub Pages (like we are), there is one final source of extended liquid functionality to be aware of ‚Äî the `github-metadata` Jekyll plugin included automatically as a dependency of the `github-pages` gem. The official (very limited) [documentation is available here](https://jekyll.github.io/github-metadata/).

## Liquid's Architecture

If you zoom out to the conceptual level, Liquid really is just an alternative to other templating engines like Mustach which we used while building client-side Javascript web apps. 

Liquid takes as input template strings which contain placeholders, and a collection of data, and produces output strings the appropriate data substituted for the placeholders. 

Where things differ is in the proverbial *plumbing*. We invoked Mistach by calling a two-argument function that returned the output strings ‚Äî we passed that function a template string with placeholders, and a data structure, and it returned a string.

With Jekyll it's our source files that act as the template strings, and Jekyll provides the data as part of the site rendering process. The results of the substitutions appear in the files that make up the generated site.

So: `input files with Liquid tags + Jekyll variables ‚Üí output files`

There are of some subtleties, but the big-picture rule is that HTML and Markdown files in the input folder always get processed with Liquid, and so do other text-based files in the input folder with front matter, but there are exceptions and you can add explicit exclusions too.

## Jekyll's Liquid Variables

Under the hood the data Jekyll presents to Liquid is actually stored in Ruby variables, but it's presented to the world as generic data compatible with both JSON and YAML. In other words, the data available for use in Liquid templates consists of arbitrarily nested combinations of simple values, lists, and dictionaries.

The core version of Liquid provides no built-in data structures, and the Shopify and Jekyll variants provide completely different sets of data.

All the data Jekyll makes available within Liquid templates is organised into a well named and well documented collection of dictionaries. The documentation refers to these dictionaries are *variables*. Some of these variables are available everywhere Jekyll processes Liquid tags, but some are only available in specific contexts. They are all so sensibly named that you're unlikely to try use the wrong variable in the wrong context.

You'll find a [full list of the variables in the Jekyll documentation](https://jekyllrb.com/docs/variables/), but some of the most important ones are:

* `site` for information related to the site as a whole.
  * When using Jekyll with GitHub Pages there is also `site.github` with additional GitHub-specific site-wide data related to the repository hosting the site.
* `page` for information related to the current page.
* `layout` for the information related to the theme layout(s) in use for building the current page.

We'll learn more about these variables later in the series as we start to use them.

## Basic Liquid Syntax ‚Äî Objects, Tags & Filters

Before we dive in, just a reminder that in this series, we always use the technically correct jargon as used in the relevant official documentation, even when it is, perhaps, not the most elegant of terminology. While it can be a little irritating, not doing so would be disempowering, because it would be so much harder to independently give deeper into the docs or interpret search results.

With that said, let's look at the three main components of the Liquid syntax ‚Äî *objects*, *tags*, and *filters*.

### Liquid Objects

Were the Shopify developers to have asked for my opinion I would definitely not have advised they name their data place-holders *objects*, but, alas, they didn't care about the opinions of a neophyte sysadmin when they made that choice way back in 2006 üòâ

Anyway, the Liquid documentation does refer to data placeholders as *liquid objects*, and the syntax is very straightforward ‚Äî simply surround the reference to some data with doubled curly braces (yes, just like Mustach)!

Liquid also uses the same basic Javascript-like syntax for referencing nested variables ‚Äî periods (`.`) to descend into dictionaries, and square beaches (`[]`) to access list elements via their zero-based indexes. So, to insert the site description from the Jekyll `site` variable you would use {% raw %}`{{ site.description }}`{% endraw %}, and to get the title of the site's first page you would use {% raw %}`{{ site.pages[0].title }}`{% endraw %}.

### Liquid Tags

If you want to use liquid for anything other than simply inserting some data, you need to use a *liquid tag*. The syntax for these is also very simple ‚Äî wrap the tag name and it's optional arguments with {% raw %}`{%`{% undraw %} and {% raw %}`%}`{% endraw %}.

Each tag has its own syntax, but to give you a flavour, you can implement conditions like so:

```markdown
{% raw %}This site {% if site.title %}is titled '{{ site.title }}'{% else %}has no title üôÅ{% endif %}{% endraw %}
```

And basic iteration like so:

```markdown
{% raw %}# Site Pages:
{% for page in site.page %}
- [{{ page.title }}]({{ page.url }})
{% else %}
*This site has no pages üôÅ*
{% endfor %}{% endraw %}
```

When using Jekyll the tags avaiable to us are a superset of those provided by the core liquid library, and those provided by Jekyll.

* The core liquid tags are broken into four categories in the official documentation:
  * Control Flow (conditionals) ‚Äî [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/tags/control-flow/)
  * Iteration (loops) ‚Äî [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/tags/iteration/)
  * Template (comments, disabling rendering, and nesting templates) ‚Äî [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/tags/template/)
  * Variables ‚Äî [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/tags/variable/)
* The tags provided by Jekyll are listed in the Jekyll docs ‚Äî [jekyllrb.com/‚Ä¶](https://jekyllrb.com/docs/liquid/tags/)

### Liquid Filters

*Liquid filters* are used to transform data when it's being rendered using liquid objects (curly braces). Filters take values as inputs and produce new values as outputs. You direct values into filters using the pipe symbol (`|`), and you can chain multiple filters together by using multiple pipes.

Simple filters don't require arguments, so you invoke them by just placing their name after the pipe, e.g. `{% raw %}{{ site.pages | size }}{% endraw %}` will output the number of pages in the site (`pages` is a list).

More complex filters expect one or more arguments, and those have to have a `:` placed after their name, followed by a coma-delimited list of arguments. A very useful example of a filter that takes an argument is `default:`. You use this filter to provide a default value for a variable that might not be defined. For example, not all pages have IDs, so you could use the following example to show a page's ID or a human-friendly message:

```markdown
{% raw %}**Page ID:** {{ page.id | default: "this page has no ID" }}{% endraw %}
```
Note that with a few exceptions, **filters can't be used inside tags**. 

One exception is the `assign` tag which is used to assign a value to a variable (more on that in a moment). 

Another interesting exception is the `size` filter which returns the number of items in an array (list), or the number of characters in a string. This filter can be invoked using the dot notation usually reserved for descending into dictionaries. For example, we can use the size of the `site.pages` list in the condition part of an `if` tag like so:

```markdown
{% raw -%}
{% if site.pages.size > 10 %}
This is a big site!
{% else %}
This is a small site.
{% endif %}
{%- endraw %}
```

The filters availible to us when working within Jekyll are a superset of those provided by the core Liquid library, and those provided by Jekyll.

* Descriptions of each of the core filters are available via the sidebar of the officaol docs ‚Äî [shopify.github.io/‚Ä¶](https://shopify.github.io/liquid/basics/introduction/)
* Descriptions of the filters provided by Jekyll can be found in the Jekyll docs ‚Äî [jekyllrb.com/‚Ä¶](https://jekyllrb.com/docs/liquid/filters/)

### Saving the Output from a Filter

As mentioned previously, you can't loop over a filtered array (list) in one step because you can't use a filter within a regular tag. The one exception is the special tag for assigning values to variables, the perfectly named `assign` tag. This means that we can loop over the results generated by a filter, but we need to do it in two steps ‚Äî first, save the filter's output to a new variable, then loop over the new variable.

For example, To loop over a list of all static Javascript files in a site we can use the `assign` tag to create a new variable named `js_files` by filtering the list of all static files in the site (`sits.static_files`) down to just those with a file extension (available via the `extname` key) with the value `js` using the `where` filter. Note that the `where` filter takes two arguments ‚Äî the name of the key whose value should be checked, and a required value for that key. Only items in a list where the value of the given key matches the given value will be returned by the filter.

```markdown
{% raw -%}
# Site Java Script Files

{%- assign js_files = site.static_files | where: "extname", ".js" %}
{%- for file in js_files %}
- `{{ file.path }}`
{%- endfor %}
{%- endraw %}
```

If you add this section to `index.md` in our demo site you'll see it only has one Javascript file ATM, `/assets/js/bootstrap.bundle.min.js`.

## Liquid Data Types

As mentioned previously, Liquid variables only support the data types supported by JSON and YAML, so it really is just the basics:

| Type | Description |
| :---: | :--- |
| Booleans | The two Boolean literals are simply `true` & `false` |
| Numbers | Numbers are simply entered as regular numbers without any kind of quotations, e.g. `42` & `3.1417` |
| Strings | Strings can be quoted with single or double quotes, e.g. `'A string'` & `"Another String"` |
| Null Values | The absensce of a value is represnted with the literal `nil` (not the mor usual `null`!) |
| Lists (*Arrays*) | The Docs referer to lists as *arrays*. Indexes are zero-based and specified inside quare braces. Negative indexes are supported, with `-1` being the index of the last element in an array. E.g. `myArray[0]`, `myArray[42]` & `myArray[-1]` |
| Dictionaries | Not listed as a separate data type in the docs, appear to be considered simply nested variable names, with each level separated with a period symbol (`.`), e.g. `myDictionary.someKey` |

Liquid also supports some **speical literals**, specifically `nil` to represent the absence of any value at all (what Javascript represents with `null`), and `empty` to represent a list or string which is defined, but has no content.

### A Note on Truthiness

In Liquid, just about everything evaluates to `true` when coerced to a boolean ‚Äî **the only things that coerce to `false` are `false` itself and `nil`**, everything else, including the number zero, empty strings, empty arrays, and empty dictionaries all coerce to `true`. This can really catch developers used to more traditional languages like Javascript by surprise!

## Operators in Liquid (For Comparisons Only!)

This might come as a surprise, but Liquid does not support any arithmetic operators! The only operators it supports are comparison operators. Arithmetic and string manipulations are performed using filters rather than operators. These are the operators you can use when making comparisons: 

| Operator | Description |
| :---: | :--- |
| `==` | Is equal to, e.g. `myString == "some string"` or `myNumber == 42` |
| `!=` | Is not equal to, e.g. `myString != "some string"` or `myNumber != 42` |
| `<` | Is less than, e.g. `myNumber < 42` |
| `>` | Is greater than, e.g. `myNumber > 42` |
| `<=` | Is less than or equal to, e.g. `myNumber <= 42` |
| `>=` | IS greater than or equal to, e.g. `myNumber >= 42` |
| `and` | Local and, e.g. `myNumber > 0 and myNumber <= 12` |
| `or` | Logical or, e.g. `myString == "ok" or myString == "yes"` |
| `contains` | Substring containment check, e.g. `myString contains "something"`. Only works on strings and arrays (lists) of strings. |

For complex comparisons, brachets (`()`) can be used to group sub-expressions.

## How Liquid Handles White Space

To stop Liquid objects and tags affecting the layout of the rendered text in unwanted ways, you can specify that all white space should be stripped before or after any object or tag by adding a minus symbol (`-`) directly inside any opening or closing delimiter.

If we assume the value of the variable `desert` is `WAFFLES`, then the following input text:

```text
I like {{ desert }} very much üôÇ
I like {{- desert }} very much üôÇ
I like {{ desert -}} very much üôÇ
I like {{- desert -}} very much üôÇ
```
Is rendered as:

```text
I like WAFFLES very much üôÇ
I likeWAFFLES very much üôÇ
I like WAFFLESvery much üôÇ
I likeWAFFLESvery much üôÇ
```

## Worked Example ‚Äî Making the List of Pages Dynamic

As promised in the previous instalment, our example real-world task is to replace the hard-coded list of pages on the home page with a dynamically generated list that will update itself automatically as you create new pages.

To do this we need to make use of the `site` variable which is a disctionary. That dictionary contains a list of all the pages that will appear in the output site that have been transformed by Jekyll named `pages`. Yoy might expect this to be exactly what we need, but it actually contains too much, because our style sheet is built by Jekyll from the original SASS code, so it appears in that list too. Don't worry though, there is a more tightly constrained list named `html_pages` which contains only the items which get rendered by Jekyll to HTML in the output. This is the list we'll use, and we'll address it by it's full name `site.html_pages`. 

Even this list actually has one more superfluous item, we don't need a link to the home page on the home page! The need to filter the page out provides the perfect opportunity to use one of the most powerful additional filters provided by Jekyll, `where_exp`. The built-in `where` filter can only filter by checking a specific key against a specific value, the `where_exp` filter lets us filter by any valid Liquid condition.

OK, let's do it!

To convert our static list of pages, replace the following lines in `index.md`

```markdown
## Site Pages

* [About](about)
* [Links](links)
```

With these updated lines:

```markdown
{% raw -%}
## Site Pages

{%- assign list_pages = site.html_pages | where_exp: "item", "item.title != 'Home'" %}
{%- for p in list_pages %}
- [{{ p.title }}]({{ p.url | relative_url }})
{%- else %}
- *No pages yet*
{%- endfor %}
{% endraw -%}
```

For your convenience you'll also find an updated for the complete new `index.md` page in the instalment ZIP.

That's not a lot of lines of code, but there's actually a lot going on there! Let's dive into some key points

Firstly, note the use of white space control minus signs to stop the generated markdown filling with blank lines.

Next, I used an `assign` tag to retrieve just the pages that will become web pages (`site.html_pages`) and pass them to one of the most powerful Jekyll-provided filters, `where_exp`. This is a more advanced fileter than the simple `where` filter we saw earlier which is part of core Liquid. The `where_exp` filter also takes two arguments, but instead of specifying a key name and an exact desired value, you provide a name of your choosing that will be assigned to each element in the list piped to the filter for use in the second argument. This second argument is where the real power comes. You pass the argument as a string, but under the hood it will be used as a Liquid condition, and only the elements in the input list that evaluate to a truthy value based on that condition are outputted.

So, what that means in this example is that all the dictionaries representing all the markdown files currently in the site get naked `item` one by one, and only the ones who's title is not `Home` pass to the filter's output and get saved to the new `list_pages` variable we're defining with the `assign` tag. 

Once we have just the pages that are not the home page in our list we just loop over it with a `for` tag and inset the values of the `title` and `url` keys into the markdown syntax for a list item containing a link.

Actually, we don't insert the raw URL, we filter it through an extremely important Jekyll-provided filter ‚Äî `relative_url`. This filter handles the fact that the file at `/test.md` in your input folder may be at a URL with another folder prefixed before it when the site is published on the web. GitHub Pages does exactly that, prefixing your username as a parent folder in all URLs! So, **without the `relative_url` filter your site would work** as expected when testing **locally**, and all your **relative URLs would break when published to Git Hub Pages**!


## Final Thoughts

Believe it or not, we've actually introduced  the basics of **almost** every important Liquid feature. Almost, but we have skipped over a rather substantial one ‚Äî how Jekyll uses nested Liquid templates to define a site's theme! That will be our focus next time.
